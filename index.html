<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>
    <script></script>

    <style>
      body {
        background-color: #333;
      }
      path.sfmappath {
        fill: lightgray;
        stroke: lightgray;
      }

      path.sfmapdistrictpath {
        fill: rgba(255, 60, 0, 0.219);
        stroke: rgb(217, 255, 0);
      }
      .foreground {
        fill: none;
        stroke: #333;
        stroke-width: 1.5px;
      }
      div.tooltip {
        position: absolute;
        text-align: center;
        width: auto;
        height: auto;
        padding: 2px;
        font: 24px sans-serif;
        background: lightsteelblue;
        border: 0px;
        border-radius: 8px;
        pointer-events: none;
      }
    </style>
    <title>Document</title>
  </head>
  <body>
    <!-- <svg width="100%" height="1200px"></svg> -->
    <script>
      var lng = -122.434469,
        lat = 37.774313;
      var scale = 400;
      var center = [lng, lat];
      const tooltip = d3
        .select("body")
        .append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);
      const svg = d3
        .select("body")
        .append("svg")
        .attr("id", "sfmap")
        .attr("width", "100%")
        .attr("height", "1000px");

      //   const myProjection = d3.geoAlbers();
      const myProjection = d3
        .geoMercator()
        .center(center)
        .scale(400000)
        .translate([window.innerWidth / 2, window.innerWidth / 4.6]);

      const path = d3.geoPath().projection(myProjection);

      function drawMap(err, geojson) {
        if (err) throw err;

        svg
          .append("g")
          .selectAll("path")
          .data(geojson.features)
          .enter()
          .append("path")
          .attr("class","sfmappath")
          .attr("d", path);
      }

      function drawPDMap(err, geojson) {
        if (err) throw err;

        svg
          .append("g")
          .selectAll("path")
          .data(geojson.features)
          .enter()
          .append("path")
          .attr("class","sfmapdistrictpath")
          .attr("d", path);
      }

      d3.queue()
        .defer(d3.json, "euSfGeo.json")
        .defer(d3.json, "PoliceDistricts.json" )
        .defer(d3.csv, "2018pdi.csv")
        .await((err, mapData, pdData,dotData) => {
          drawMap(err, mapData);
          drawPDMap(err, pdData)
          let expenseCount = 
          d3.nest()
            .key((d)=>d.PdDistrict)
            .rollup((v)=>v.length)
            .entries(dotData)

           console.log(expenseCount) 
                              
          // plotDots(err, dotData,4);
          // d3.select("body").append("h1")
          // var stepper = setInterval((function(){
          //   var step = 0,
          //       month = 12;
          //       return function(){
          //         year = timeline_step(step++, month)
          //       }
          // })(),1000);

          // function timeline_step(step, month){
          //   d3.select("h1").html(step)
          //   requestAnimationFrame(function(){
          //     plotDots(err, dotData, step)
          //   })
          //   if (step >= month){
          //     clearInterval(stepper)
          //   }

          //   return month

          // }
        });

      // d3.json("euSfGeo.json", drawMap);
      let categories = [];
      function plotDots(err, d, month) {
        if (err) throw error;
        coor = d.filter(point=>new Date(point.Date).getMonth() === month).map(point => {
          !categories.includes(point.Category)
            ? categories.push(point.Category)
            : null;
            debugger
          return {
            id: point.IncidntNum,
            category: point.Category,
            coordinates: [+point.X, +point.Y]
          };
        });

        // d3.select("body")
        //   .append("fieldset")
        //   .selectAll("input")
        //   .data(categories)
        //   .enter()
        //   .append("input")
        //   .attr("type", "checkbox")
        //   .attr("id", "categories")
        //   .attr("checked","")
        //   .attr("value", d => d)
          
        // d3.selectAll("input#categories").on('click', (d)=>{
        //  d3.selectAll("circle").filter(circle=>circle.category === d).style("opacity", 0)
        // //  d3.selectAll("circle").filter(circle=>circle.category !== d).style("opacity", 100)
        // })

        svg
          .append("g")
          .selectAll("circle")
          .data(coor)
          .enter()
          .append("circle")
          .attr("cy", d => myProjection(d.coordinates)[1])
          .attr("cx", d => myProjection(d.coordinates)[0])
          .attr("r", 2)
          .attr("fill", "red")  
          .attr("id", d => d.id)
          // .transition().style("opacity","0").duration(2000)
          .attr("category", d => d.category)
          .on("mouseover", function(d) {
            d3.select(this).style("fill", "orange");
            tooltip
              .transition()
              .duration(200)
              .style("opacity", 0.9);
            let coordHtmlInfo = `Category: ${d.category}, lat: ${
              d.coordinates[1]
            }, lng: ${d.coordinates[0]}`;
            tooltip.html(coordHtmlInfo);
            // Get x & y co-ordinates in pixels
            // console.log(d3.mouse(this));
          })
          .on("mouseout", function(d) {
            d3.select(this).style("fill", "red");
            tooltip
              .transition()
              .duration(200)
              .style("opacity", 0);
          });
      }
    </script>
  </body>
</html>
